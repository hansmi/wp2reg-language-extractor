package main

import (
	"bytes"
	"errors"
	"io"
	"regexp"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestParseLangFile(t *testing.T) {
	for _, tc := range []struct {
		name      string
		input     io.Reader
		want      []string
		wantErr   error
		wantErrRe *regexp.Regexp
	}{
		{
			name:      "empty",
			input:     bytes.NewReader(nil),
			wantErr:   io.EOF,
			wantErrRe: regexp.MustCompile(`^reading 16 byte header failed`),
		},
		{
			name: "header only",
			input: bytes.NewReader([]byte{
				0x12, 0x5A, 0x45, 0x89, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			}),
			want: []string{},
		},
		{
			name: "wrong magic",
			input: bytes.NewReader([]byte{
				0xAA, 0xBB, 0xCC, 0xDD, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			}),
			wantErrRe: regexp.MustCompile(`^magic mismatch;`),
		},
		{
			name: "short read",
			input: bytes.NewReader([]byte{
				0x12, 0x5A, 0x45, 0x89, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			}),
			wantErr: io.ErrUnexpectedEOF,
		},
		{
			name: "one entry",
			input: bytes.NewReader([]byte{
				0x12, 0x5A, 0x45, 0x89, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x41, 0x00, 0x42, 0x00, 0x00, 0x00,
			}),
			want: []string{
				"AB",
			},
		},
		{
			name: "Unicode",
			input: bytes.NewReader([]byte{
				0x12, 0x5A, 0x45, 0x89, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,

				// Offsets
				0x00, 0x00, 0x00, 0x00,
				0x03, 0x00, 0x00, 0x00,
				0x07, 0x00, 0x00, 0x00,
				0x08, 0x00, 0x00, 0x00,

				// Text data
				0x61, 0x00, 0x62, 0x00, 0x00, 0x00,
				0x41, 0x00, 0x52, 0x01, 0x42, 0x00, 0x00, 0x00,
				0x00, 0x00,
				0x48, 0x00, 0x65, 0x00, 0x6c, 0x00, 0x6c, 0x00, 0x6f, 0x00,
				0x20, 0x00, 0x77, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x6c, 0x00,
				0x64, 0x00, 0x20, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00,
				0x33, 0x00, 0x34, 0x00, 0x35, 0x00, 0x36, 0x00, 0x37, 0x00,
				0x38, 0x00, 0x39, 0x00, 0x00, 0x00,
			}),
			want: []string{
				"ab",
				"A\u0152B",
				"",
				"Hello world 0123456789",
			},
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			got, err := parseLangFile(tc.input)

			if diff := cmp.Diff(tc.want, got); diff != "" {
				t.Errorf("parseLangFile() difference (-want +got):\n%s", diff)
			}

			if tc.wantErr == nil && tc.wantErrRe == nil && err != nil {
				t.Errorf("parseLangFile() failed: %v", err)
			}

			if tc.wantErr != nil {
				if err == nil {
					t.Errorf("parseLangFile() didn't fail, want %v", tc.wantErr)
				} else if !errors.Is(err, tc.wantErr) {
					t.Errorf("parseLangFile() failed with %v, want %v", err, tc.wantErr)
				}
			}

			if tc.wantErrRe != nil {
				if err == nil {
					t.Errorf("parseLangFile() didn't fail, want match for %q", tc.wantErrRe.String())
				} else if !tc.wantErrRe.MatchString(err.Error()) {
					t.Errorf("parseLangFile() failed with %q, want match for %q", err.Error(), tc.wantErrRe.String())
				}
			}
		})
	}
}
